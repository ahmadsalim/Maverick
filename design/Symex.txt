[
pkg = package((?cln : class(?cln, (?ofn : ?of, ?Fn : ?F), ?methods, ?super), ?Clns : ?Cls))
cl = ?cln
oldFieldName = ?ofn
newFieldName = ?nfn
|
?nfn \notin ?Fn
]

--‹ Field fieldDef = pkg.classes[cl].fields[oldFieldName]; ›-->

[
pkg = package((?cln : class(?cln, (?ofn : ?of, ?Fn : ?F), ?methods, ?super), ?Clns : ?Cls))
cl = ?cln
oldFieldName = ?ofn
newFieldName = ?nfn
fieldDef = ?of
|
?nfn \notin ?Fn
]

--‹ fieldDef.name = newFieldName; ›-->

{{ ?of ~ field(?ofn, ?oftyp) }}

[
pkg = package((?cln : class(?cln, (?ofn : field(?ofn, ?oftyp), ?Fn : ?F), ?methods, ?super), ?Clns : ?Cls))
cl = ?cln
oldFieldName = ?ofn
newFieldName = ?nfn
fieldDef = field(?nfn, ?oftyp)
|
?nfn \notin ?Fn
]

--‹ pkg.classes[cl].fields = delete(pkg.classes[cl].fields, oldFieldName) + (newFieldName: fieldDef); ›-->

[
pkg = package((?cln : class(?cln, (?Fn : ?F, ?nfn : field(?nfn, ?oftyp)), ?methods, ?super), ?Clns : ?Cls))
cl = ?cln
oldFieldName = ?ofn
newFieldName = ?nfn
fieldDef = field(?nfn, ?oftyp)
|
?nfn \notin ?Fn
]

--‹ top-down visit(pkg) {
		case fae : fieldaccessexpr(faty, target, oldFieldName) => ...p
	} ›-->

{{ Sketching visiting:

visit(package((?cln : class(?cln, (?Fn : ?F, ?nfn : field(?nfn, ?oftyp)), ?methods, ?super), ?Clns : ?Cls))) -> no case match
-> visit((?cln : class(?cln, (?Fn : ?F, ?nfn : field(?nfn, ?oftyp)), ?methods, ?super), ?Clns : ?Cls)) -> no case match
--> visit(?cln) -> no case match
--> visit(class(?cln, (?Fn : ?F, ?nfn : field(?nfn, ?oftyp)), ?methods, ?super)) -> no case match
---> visit(?cln) -> no case match
---> visit((?Fn : ?F, ?nfn : field(?nfn, ?oftyp))) -> no case match
----> visit(?Fn) -> no case match
----> visit(?F) -> no case match
----> visit(?nfn) -> no case match
----> visit(field(?nfn, ?oftyp)) -> no case match
-----> visit(?nfn) -> no case match/no containment match
-----> visit(?oftyp) -> no case match/no containment match
---> visit(?methods) no case match/containment match!
===> new symbol ?Es s.t. ?methods//Expr == ?Es
-----> visit(?Es)
=====> Non-deterministically partition ?Es == Ø \/ (?Es == ?e +U+ ?Es')
------> visit(?e) -> possible case match
======> Non-deterministically have (fae : fieldaccessexpr(faty, target, ?ofn)) := ?e \/ (fae : fieldaccessexpr(faty, target, ?ofn)) :!= ?e
------> Execute replacement action ...p with fae = fieldaccessexpr(?faty, ?targete, ?ofn) unifying ?e with fieldaccessexpr(?faty, ?targete, ?ofn) (* what about descendant constraints? *)
======> Do another iteration (SE)/find fixedpoint (AI) if needed when no match
======> visting finished on ?Es == Ø
---> visit(?super) -> no case match/no containment match
--> visit(?Clns) -> no case match/no containment match
--> visit(?Cls) --> Iterate in similar way to methods
}}

[
pkg = package((?cln : class(?cln, (?Fn : ?F, ?nfn : field(?nfn, ?oftyp)), ?methods, ?super), ?Clns : ?Cls))
cl = ?cln
oldFieldName = ?ofn
newFieldName = ?nfn
fieldDef = field(?nfn, ?oftyp)
fae = fieldaccessexpr(?faty, ?targete, ?ofn)
|
?nfn \notin ?Fn
?methods//Expr == fieldaccessexpr(?faty, ?targete, ?ofn) +U+ ?targete +U+ ?Es''
]

--‹
  { if (target.typ == cl) fieldaccessexpr(faty, target, newFieldName); else fae; }
	} ›‹true›--> 

[
pkg = package((?cln : class(?cln, (?Fn : ?F, ?nfn : field(?nfn, ?oftyp)), ?methods, ?super), ?Clns : ?Cls))
cl = ?cln
oldFieldName = ?ofn
newFieldName = ?nfn
fieldDef = field(?nfn, ?oftyp)
fae = fieldaccessexpr(?cln, ?targete, ?ofn)
|
?nfn \notin ?Fn
?methods//Expr == fieldaccessexpr(?cln, ?targete, ?ofn) +U+ ?targete +U+ ?Es''
]

--‹  fieldaccessexpr(faty, target, newFieldName) - update after visit ›-->
[
pkg = package((?cln : class(?cln, (?Fn : ?F, ?nfn : field(?nfn, ?oftyp)), ?methods, ?super), ?Clns : ?Cls))
cl = ?cln
oldFieldName = ?ofn
newFieldName = ?nfn
fieldDef = field(?nfn, ?oftyp)
fae = fieldaccessexpr(?cln, ?targete, ?ofn)
|
?nfn \notin ?Fn
?methods//Expr == fieldaccessexpr(?cln, ?targete, ?nfn) +U+ ?targete +U+ ?Es''
]

--‹
  { if (target.typ == cl) fieldaccessexpr(faty, target, newFieldName); else fae; }
	} ›‹false›--> 

[
pkg = package((?cln : class(?cln, (?Fn : ?F, ?nfn : field(?nfn, ?oftyp)), ?methods, ?super), ?Clns : ?Cls))
cl = ?cln
oldFieldName = ?ofn
newFieldName = ?nfn
fieldDef = field(?nfn, ?oftyp)
fae = fieldaccessexpr(?fae, ?targete, ?ofn)
|
?nfn \notin ?Fn
?methods//Expr == fieldaccessexpr(?fae, ?targete, ?ofn) +U+ ?targete +U+ ?Es''
?fae != ?cln
]

--‹ merge/if ›--> 

[
pkg = package((?cln : class(?cln, (?Fn : ?F, ?nfn : field(?nfn, ?oftyp)), ?methods, ?super), ?Clns : ?Cls))
cl = ?cln
oldFieldName = ?ofn
newFieldName = ?nfn
fieldDef = field(?nfn, ?oftyp)
fae = fieldaccessexpr(?fae, ?targete, ?ofn)
|
?nfn \notin ?Fn
?methods//Expr == fieldaccessexpr(?fae, ?targete, (if (?fae == ?cln) ?ofn ?nfn) +U+ ?targete +U+ ?Es''
?fae != ?cln
]

--‹ merge/case ›-->

[
pkg = package((?cln : class(?cln, (?Fn : ?F, ?nfn : field(?nfn, ?oftyp)), ?methods, ?super), ?Clns : ?Cls))
cl = ?cln
oldFieldName = ?ofn
newFieldName = ?nfn
fieldDef = field(?nfn, ?oftyp)
fae = fieldaccessexpr(?fae, ?targete, ?ofn)
|
?nfn \notin ?Fn
?methods//Expr == (if (fieldaccessexpr(?fae, ?targete, ?ofn) := ?e) fieldaccessexpr(?fae, ?targete, (if (?fae == ?cln) ?ofn ?nfn)) ?e) +U+ ?Es'
?Es' == (if (fieldaccessexpr(?fae, ?targete, ?ofn) := ?e) ?targete Ø) +U+ ?Es''
?fae != ?cln
]
